; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\usart.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\user -I.\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\Libraries\CMSIS\CM3\CoreSupport -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\APP\LED -I.\APP\SysTick -I.\APP\beep -I.\APP\key -I.\APP\usart -I.\APP\printf -I.\APP\HC05 -I.\Libraries\STM32F10x_StdPeriph_Driver\inc -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\output\usart.crf APP\usart\usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM4_Set PROC
;;;125    //sta:0，关闭;1,开启;
;;;126    void TIM4_Set(u8 sta)
000000  b510              PUSH     {r4,lr}
;;;127    {
000002  4604              MOV      r4,r0
;;;128        if(sta)
000004  b144              CBZ      r4,|L1.24|
;;;129        {
;;;130    
;;;131            TIM_SetCounter(TIM4,0);//计数器清空
000006  2100              MOVS     r1,#0
000008  4879              LDR      r0,|L1.496|
00000a  f7fffffe          BL       TIM_SetCounter
;;;132            TIM_Cmd(TIM4, ENABLE);  //使能TIMx    
00000e  2101              MOVS     r1,#1
000010  4877              LDR      r0,|L1.496|
000012  f7fffffe          BL       TIM_Cmd
000016  e003              B        |L1.32|
                  |L1.24|
;;;133        }else TIM_Cmd(TIM4, DISABLE);//关闭定时器4      
000018  2100              MOVS     r1,#0
00001a  4875              LDR      r0,|L1.496|
00001c  f7fffffe          BL       TIM_Cmd
                  |L1.32|
;;;134    }
000020  bd10              POP      {r4,pc}
;;;135    
                          ENDP

                  USART1_IRQHandler PROC
;;;17     
;;;18     void USART1_IRQHandler(void){
000022  b510              PUSH     {r4,lr}
;;;19         u8 res;
;;;20         
;;;21         if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET){//接收到数据
000024  f2405125          MOV      r1,#0x525
000028  4872              LDR      r0,|L1.500|
00002a  f7fffffe          BL       USART_GetITStatus
00002e  b300              CBZ      r0,|L1.114|
;;;22             res =USART_ReceiveData(USART1);     
000030  4870              LDR      r0,|L1.500|
000032  f7fffffe          BL       USART_ReceiveData
000036  b2c4              UXTB     r4,r0
;;;23             if(USART1_RX_STA < USART1_MAX_RECV_LEN){       //还可以接收数据
000038  486f              LDR      r0,|L1.504|
00003a  8800              LDRH     r0,[r0,#0]  ; USART1_RX_STA
00003c  28c8              CMP      r0,#0xc8
00003e  da12              BGE      |L1.102|
;;;24                 TIM_SetCounter(TIM4,0);//计数器清空                       
000040  2100              MOVS     r1,#0
000042  486b              LDR      r0,|L1.496|
000044  f7fffffe          BL       TIM_SetCounter
;;;25                 if(USART1_RX_STA == 0){
000048  486b              LDR      r0,|L1.504|
00004a  8800              LDRH     r0,[r0,#0]  ; USART1_RX_STA
00004c  b910              CBNZ     r0,|L1.84|
;;;26                     TIM4_Set(1);        //使能定时器4的中断 
00004e  2001              MOVS     r0,#1
000050  f7fffffe          BL       TIM4_Set
                  |L1.84|
;;;27                 }
;;;28                 USART1_RX_BUF[USART1_RX_STA++]=res;     //记录接收到的值    
000054  4868              LDR      r0,|L1.504|
000056  8801              LDRH     r1,[r0,#0]  ; USART1_RX_STA
000058  8800              LDRH     r0,[r0,#0]  ; USART1_RX_STA
00005a  1c40              ADDS     r0,r0,#1
00005c  4a66              LDR      r2,|L1.504|
00005e  8010              STRH     r0,[r2,#0]
000060  4866              LDR      r0,|L1.508|
000062  5444              STRB     r4,[r0,r1]
000064  e005              B        |L1.114|
                  |L1.102|
;;;29             }else{
;;;30                 USART1_RX_STA|=1<<15;                   //强制标记接收完成
000066  4864              LDR      r0,|L1.504|
000068  8800              LDRH     r0,[r0,#0]  ; USART1_RX_STA
00006a  f4404000          ORR      r0,r0,#0x8000
00006e  4962              LDR      r1,|L1.504|
000070  8008              STRH     r0,[r1,#0]
                  |L1.114|
;;;31             } 
;;;32         }                                            
;;;33     }   
000072  bd10              POP      {r4,pc}
;;;34     
                          ENDP

                  TIM4_Init PROC
;;;89     //psc：时钟预分频数         
;;;90     void TIM4_Init(u16 arr,u16 psc)
000074  b57f              PUSH     {r0-r6,lr}
;;;91     {   
000076  4605              MOV      r5,r0
000078  460c              MOV      r4,r1
;;;92         NVIC_InitTypeDef NVIC_InitStructure;
;;;93         TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;94     
;;;95         RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE); //时钟使能//TIM4时钟使能    
00007a  2101              MOVS     r1,#1
00007c  2004              MOVS     r0,#4
00007e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;96     
;;;97         //定时器TIM4初始化
;;;98         TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值   
000082  f8ad5004          STRH     r5,[sp,#4]
;;;99         TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值
000086  f8ad4000          STRH     r4,[sp,#0]
;;;100        TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim
00008a  2000              MOVS     r0,#0
00008c  f8ad0006          STRH     r0,[sp,#6]
;;;101        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
000090  f8ad0002          STRH     r0,[sp,#2]
;;;102        TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure); //根据指定的参数初始化TIMx的时间基数单位
000094  4669              MOV      r1,sp
000096  4856              LDR      r0,|L1.496|
000098  f7fffffe          BL       TIM_TimeBaseInit
;;;103    
;;;104        TIM_ITConfig(TIM4,TIM_IT_Update,ENABLE ); //使能指定的TIM4中断,允许更新中断
00009c  2201              MOVS     r2,#1
00009e  4611              MOV      r1,r2
0000a0  4853              LDR      r0,|L1.496|
0000a2  f7fffffe          BL       TIM_ITConfig
;;;105    
;;;106    
;;;107        NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
0000a6  201e              MOVS     r0,#0x1e
0000a8  f88d000c          STRB     r0,[sp,#0xc]
;;;108        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1 ;//抢占优先级1
0000ac  2001              MOVS     r0,#1
0000ae  f88d000d          STRB     r0,[sp,#0xd]
;;;109        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;      //子优先级2
0000b2  2002              MOVS     r0,#2
0000b4  f88d000e          STRB     r0,[sp,#0xe]
;;;110        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;         //IRQ通道使能
0000b8  2001              MOVS     r0,#1
0000ba  f88d000f          STRB     r0,[sp,#0xf]
;;;111        NVIC_Init(&NVIC_InitStructure); //根据指定的参数初始化VIC寄存器
0000be  a803              ADD      r0,sp,#0xc
0000c0  f7fffffe          BL       NVIC_Init
;;;112    
;;;113    }
0000c4  bd7f              POP      {r0-r6,pc}
;;;114    //定时器4中断服务程序            
                          ENDP

                  USART1_Init PROC
;;;36     //bound:波特率  
;;;37     void USART1_Init(u32 bound){
0000c6  b510              PUSH     {r4,lr}
0000c8  b086              SUB      sp,sp,#0x18
0000ca  4604              MOV      r4,r0
;;;38         GPIO_InitTypeDef GPIO_InitStructure;
;;;39         USART_InitTypeDef USART_InitStructure;
;;;40         NVIC_InitTypeDef NVIC_InitStructure;
;;;41     
;;;42         RCC_APB2PeriphClockCmd(RCC_USART,ENABLE);
0000cc  2101              MOVS     r1,#1
0000ce  2004              MOVS     r0,#4
0000d0  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;43         RCC_APB2PeriphClockCmd(RCC_TX,ENABLE);
0000d4  2101              MOVS     r1,#1
0000d6  2004              MOVS     r0,#4
0000d8  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;44         RCC_APB2PeriphClockCmd(RCC_RX,ENABLE);
0000dc  2101              MOVS     r1,#1
0000de  2004              MOVS     r0,#4
0000e0  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;45     
;;;46     
;;;47         USART_DeInit(USART);  //复位串口
0000e4  4843              LDR      r0,|L1.500|
0000e6  f7fffffe          BL       USART_DeInit
;;;48     
;;;49         //UART2_TX PA.2
;;;50         GPIO_InitStructure.GPIO_Pin=USART_TX_Pin;
0000ea  f44f7000          MOV      r0,#0x200
0000ee  f8ad0014          STRH     r0,[sp,#0x14]
;;;51         GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
0000f2  2003              MOVS     r0,#3
0000f4  f88d0016          STRB     r0,[sp,#0x16]
;;;52         GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;
0000f8  2018              MOVS     r0,#0x18
0000fa  f88d0017          STRB     r0,[sp,#0x17]
;;;53         GPIO_Init(GPIOA,&GPIO_InitStructure);
0000fe  a905              ADD      r1,sp,#0x14
000100  483f              LDR      r0,|L1.512|
000102  f7fffffe          BL       GPIO_Init
;;;54     
;;;55         //USART1_RX   PA.3
;;;56         GPIO_InitStructure.GPIO_Pin=USART_RX_Pin;
000106  f44f6080          MOV      r0,#0x400
00010a  f8ad0014          STRH     r0,[sp,#0x14]
;;;57         GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
00010e  2003              MOVS     r0,#3
000110  f88d0016          STRB     r0,[sp,#0x16]
;;;58         GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING; //浮空输入
000114  2004              MOVS     r0,#4
000116  f88d0017          STRB     r0,[sp,#0x17]
;;;59         GPIO_Init(GPIOA,&GPIO_InitStructure);
00011a  a905              ADD      r1,sp,#0x14
00011c  4838              LDR      r0,|L1.512|
00011e  f7fffffe          BL       GPIO_Init
;;;60     
;;;61         USART_InitStructure.USART_BaudRate = bound;//一般设置为9600;
000122  9401              STR      r4,[sp,#4]
;;;62         USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
000124  2000              MOVS     r0,#0
000126  f8ad0008          STRH     r0,[sp,#8]
;;;63         USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
00012a  f8ad000a          STRH     r0,[sp,#0xa]
;;;64         USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
00012e  f8ad000c          STRH     r0,[sp,#0xc]
;;;65         USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
000132  f8ad0010          STRH     r0,[sp,#0x10]
;;;66         USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式
000136  200c              MOVS     r0,#0xc
000138  f8ad000e          STRH     r0,[sp,#0xe]
;;;67     
;;;68         USART_Init(USART,&USART_InitStructure); //初始化串口
00013c  a901              ADD      r1,sp,#4
00013e  482d              LDR      r0,|L1.500|
000140  f7fffffe          BL       USART_Init
;;;69     
;;;70         //UART_DMA_Config(DMA1_Channel7,(u32)&USART1->DR,(u32)USART1_TX_BUF);//DMA1通道7,外设为串口2,存储器为USART1_TX_BUF 
;;;71         USART_Cmd(USART1, ENABLE);                    //使能串口 
000144  2101              MOVS     r1,#1
000146  482b              LDR      r0,|L1.500|
000148  f7fffffe          BL       USART_Cmd
;;;72     
;;;73         #ifdef USART1_RX_EN         //如果使能了接收
;;;74         //使能接收中断
;;;75         USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启中断   
00014c  2201              MOVS     r2,#1
00014e  f2405125          MOV      r1,#0x525
000152  4828              LDR      r0,|L1.500|
000154  f7fffffe          BL       USART_ITConfig
;;;76     
;;;77         NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000158  2025              MOVS     r0,#0x25
00015a  f88d0000          STRB     r0,[sp,#0]
;;;78         NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2 ;//抢占优先级2
00015e  2002              MOVS     r0,#2
000160  f88d0001          STRB     r0,[sp,#1]
;;;79         NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;      //子优先级3
000164  2003              MOVS     r0,#3
000166  f88d0002          STRB     r0,[sp,#2]
;;;80         NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;         //IRQ通道使能
00016a  2001              MOVS     r0,#1
00016c  f88d0003          STRB     r0,[sp,#3]
;;;81         NVIC_Init(&NVIC_InitStructure); //根据指定的参数初始化VIC寄存器
000170  4668              MOV      r0,sp
000172  f7fffffe          BL       NVIC_Init
;;;82         TIM4_Init(99,7199);     //10ms中断
000176  f641411f          MOV      r1,#0x1c1f
00017a  2063              MOVS     r0,#0x63
00017c  f7fffffe          BL       TIM4_Init
;;;83         USART1_RX_STA=0;        //清零
000180  2000              MOVS     r0,#0
000182  491d              LDR      r1,|L1.504|
000184  8008              STRH     r0,[r1,#0]
;;;84         TIM4_Set(0);            //关闭定时器4
000186  f7fffffe          BL       TIM4_Set
;;;85         #endif      
;;;86     }
00018a  b006              ADD      sp,sp,#0x18
00018c  bd10              POP      {r4,pc}
;;;87     
                          ENDP

                  TIM4_IRQHandler PROC
;;;114    //定时器4中断服务程序            
;;;115    void TIM4_IRQHandler(void)
00018e  b510              PUSH     {r4,lr}
;;;116    {   
;;;117        if (TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET)//是更新中断
000190  2101              MOVS     r1,#1
000192  4817              LDR      r0,|L1.496|
000194  f7fffffe          BL       TIM_GetITStatus
000198  b160              CBZ      r0,|L1.436|
;;;118        {                  
;;;119            USART1_RX_STA|=1<<15;   //标记接收完成
00019a  4817              LDR      r0,|L1.504|
00019c  8800              LDRH     r0,[r0,#0]  ; USART1_RX_STA
00019e  f4404000          ORR      r0,r0,#0x8000
0001a2  4915              LDR      r1,|L1.504|
0001a4  8008              STRH     r0,[r1,#0]
;;;120            TIM_ClearITPendingBit(TIM4, TIM_IT_Update  );  //清除TIMx更新中断标志    
0001a6  2101              MOVS     r1,#1
0001a8  4811              LDR      r0,|L1.496|
0001aa  f7fffffe          BL       TIM_ClearITPendingBit
;;;121            TIM4_Set(0);            //关闭TIM4  
0001ae  2000              MOVS     r0,#0
0001b0  f7fffffe          BL       TIM4_Set
                  |L1.436|
;;;122        }       
;;;123    }
0001b4  bd10              POP      {r4,pc}
;;;124    //设置TIM4的开关
                          ENDP

                  u2_printf PROC
;;;137    //确保一次发送数据不超过USART1_MAX_SEND_LEN字节
;;;138    void u2_printf(char* fmt,...)  
0001b6  b40f              PUSH     {r0-r3}
;;;139    {  
0001b8  b538              PUSH     {r3-r5,lr}
;;;140        va_list ap;
;;;141        va_start(ap,fmt);
0001ba  a805              ADD      r0,sp,#0x14
0001bc  9000              STR      r0,[sp,#0]
;;;142        vsprintf((char*)USART1_TX_BUF,fmt,ap);
0001be  4811              LDR      r0,|L1.516|
0001c0  9a00              LDR      r2,[sp,#0]
0001c2  9904              LDR      r1,[sp,#0x10]
0001c4  f7fffffe          BL       __c89vsprintf
;;;143        va_end(ap);
0001c8  2000              MOVS     r0,#0
0001ca  9000              STR      r0,[sp,#0]
;;;144        while(DMA_GetCurrDataCounter(DMA1_Channel7)!=0);    //等待通道7传输完成   
0001cc  bf00              NOP      
                  |L1.462|
0001ce  480e              LDR      r0,|L1.520|
0001d0  f7fffffe          BL       DMA_GetCurrDataCounter
0001d4  2800              CMP      r0,#0
0001d6  d1fa              BNE      |L1.462|
;;;145        UART_DMA_Enable(DMA1_Channel7,strlen((const char*)USART1_TX_BUF));  //通过dma发送出去
0001d8  480a              LDR      r0,|L1.516|
0001da  f7fffffe          BL       strlen
0001de  4604              MOV      r4,r0
0001e0  4621              MOV      r1,r4
0001e2  4809              LDR      r0,|L1.520|
0001e4  f7fffffe          BL       UART_DMA_Enable
;;;146    }
0001e8  bc38              POP      {r3-r5}
0001ea  f85dfb14          LDR      pc,[sp],#0x14
;;;147    
                          ENDP

0001ee  0000              DCW      0x0000
                  |L1.496|
                          DCD      0x40000800
                  |L1.500|
                          DCD      0x40013800
                  |L1.504|
                          DCD      USART1_RX_STA
                  |L1.508|
                          DCD      USART1_RX_BUF
                  |L1.512|
                          DCD      0x40010800
                  |L1.516|
                          DCD      USART1_TX_BUF
                  |L1.520|
                          DCD      0x40020080

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  USART1_TX_BUF
                          %        200
                  USART1_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=1

                  USART1_RX_STA
000000  0000              DCW      0x0000
