; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\hc05.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\hc05.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\user -I.\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\Libraries\CMSIS\CM3\CoreSupport -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\APP\LED -I.\APP\SysTick -I.\APP\beep -I.\APP\key -I.\APP\usart -I.\APP\printf -I.\APP\HC05 -I.\Libraries\STM32F10x_StdPeriph_Driver\inc -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\output\hc05.crf APP\HC05\hc05.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  HC05_Init PROC
;;;6      //返回值:0,成功;1,失败.
;;;7      u8 HC05_Init(void){
000000  b5f8              PUSH     {r3-r7,lr}
;;;8          u8 retry=10,t;           
000002  260a              MOVS     r6,#0xa
;;;9          u8 temp=1;
000004  2501              MOVS     r5,#1
;;;10     
;;;11         GPIO_InitTypeDef GPIO_InitStructure;
;;;12     
;;;13         RCC_APB2PeriphClockCmd(RCC_EN|RCC_STATE,ENABLE);    //使能PORTA C时钟   
000006  2101              MOVS     r1,#1
000008  2014              MOVS     r0,#0x14
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;14     
;;;15         GPIO_InitStructure.GPIO_Pin = STATE_Pin;                 // 端口配置
00000e  2010              MOVS     r0,#0x10
000010  f8ad0000          STRH     r0,[sp,#0]
;;;16         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;            //上拉输入
000014  2048              MOVS     r0,#0x48
000016  f88d0003          STRB     r0,[sp,#3]
;;;17         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;        //IO口速度为50MHz
00001a  2003              MOVS     r0,#3
00001c  f88d0002          STRB     r0,[sp,#2]
;;;18         GPIO_Init(GPIOA, &GPIO_InitStructure);                   //根据设定参数初始化PA4
000020  4669              MOV      r1,sp
000022  486e              LDR      r0,|L1.476|
000024  f7fffffe          BL       GPIO_Init
;;;19     
;;;20     
;;;21         GPIO_InitStructure.GPIO_Pin = EN_Pin;                // 端口配置
000028  2020              MOVS     r0,#0x20
00002a  f8ad0000          STRH     r0,[sp,#0]
;;;22         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;         //推挽输出
00002e  2010              MOVS     r0,#0x10
000030  f88d0003          STRB     r0,[sp,#3]
;;;23         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;        //IO口速度为50MHz
000034  2003              MOVS     r0,#3
000036  f88d0002          STRB     r0,[sp,#2]
;;;24         GPIO_Init(GPIOC, &GPIO_InitStructure);                   //根据设定参数初始化PC4
00003a  4669              MOV      r1,sp
00003c  4868              LDR      r0,|L1.480|
00003e  f7fffffe          BL       GPIO_Init
;;;25     
;;;26         GPIO_SetBits(GPIOC,EN_Pin);
000042  2120              MOVS     r1,#0x20
000044  4866              LDR      r0,|L1.480|
000046  f7fffffe          BL       GPIO_SetBits
;;;27     
;;;28         USART1_Init(9600);  //初始化串口2为:9600,波特率.
00004a  f44f5016          MOV      r0,#0x2580
00004e  f7fffffe          BL       USART1_Init
;;;29         delay_ms(1500);
000052  f24050dc          MOV      r0,#0x5dc
000056  f7fffffe          BL       delay_ms
;;;30     
;;;31         while(retry--){
00005a  e033              B        |L1.196|
                  |L1.92|
;;;32             GPIO_SetBits(GPIOC,EN_Pin);         //KEY置高,进入AT模式
00005c  2120              MOVS     r1,#0x20
00005e  4860              LDR      r0,|L1.480|
000060  f7fffffe          BL       GPIO_SetBits
;;;33             delay_ms(10);
000064  200a              MOVS     r0,#0xa
000066  f7fffffe          BL       delay_ms
;;;34             u2_printf("AT\r\n");                //发送AT测试指令
00006a  a05e              ADR      r0,|L1.484|
00006c  f7fffffe          BL       u2_printf
;;;35             GPIO_ResetBits(GPIOC,EN_Pin);       //KEY拉低,退出AT模式
000070  2120              MOVS     r1,#0x20
000072  485b              LDR      r0,|L1.480|
000074  f7fffffe          BL       GPIO_ResetBits
;;;36             for(t=0;t<10;t++)                   //最长等待50ms,来接收HC05模块的回应
000078  2400              MOVS     r4,#0
00007a  e00a              B        |L1.146|
                  |L1.124|
;;;37             {
;;;38                 if(USART1_RX_STA & 0X8000)
00007c  485b              LDR      r0,|L1.492|
00007e  8800              LDRH     r0,[r0,#0]  ; USART1_RX_STA
000080  f4104f00          TST      r0,#0x8000
000084  d000              BEQ      |L1.136|
;;;39                     break;
000086  e006              B        |L1.150|
                  |L1.136|
;;;40                 delay_ms(5);
000088  2005              MOVS     r0,#5
00008a  f7fffffe          BL       delay_ms
00008e  1c60              ADDS     r0,r4,#1              ;36
000090  b2c4              UXTB     r4,r0                 ;36
                  |L1.146|
000092  2c0a              CMP      r4,#0xa               ;36
000094  dbf2              BLT      |L1.124|
                  |L1.150|
000096  bf00              NOP                            ;39
;;;41             }       
;;;42             if(USART1_RX_STA & 0X8000)    //接收到一次数据了
000098  4854              LDR      r0,|L1.492|
00009a  8800              LDRH     r0,[r0,#0]  ; USART1_RX_STA
00009c  f4104f00          TST      r0,#0x8000
0000a0  d010              BEQ      |L1.196|
;;;43             {
;;;44                 temp=USART1_RX_STA & 0X7FFF;  //得到数据长度
0000a2  4852              LDR      r0,|L1.492|
0000a4  7805              LDRB     r5,[r0,#0]  ; USART1_RX_STA
;;;45                 USART1_RX_STA=0;             
0000a6  2000              MOVS     r0,#0
0000a8  4950              LDR      r1,|L1.492|
0000aa  8008              STRH     r0,[r1,#0]
;;;46                 if(temp == 4 && USART1_RX_BUF[0] == 'O' && USART1_RX_BUF[1] == 'K')
0000ac  2d04              CMP      r5,#4
0000ae  d109              BNE      |L1.196|
0000b0  484f              LDR      r0,|L1.496|
0000b2  7800              LDRB     r0,[r0,#0]  ; USART1_RX_BUF
0000b4  284f              CMP      r0,#0x4f
0000b6  d105              BNE      |L1.196|
0000b8  484d              LDR      r0,|L1.496|
0000ba  7840              LDRB     r0,[r0,#1]  ; USART1_RX_BUF
0000bc  284b              CMP      r0,#0x4b
0000be  d101              BNE      |L1.196|
;;;47                 {
;;;48                     temp=0;//接收到OK响应
0000c0  2500              MOVS     r5,#0
;;;49                     break;
0000c2  e004              B        |L1.206|
                  |L1.196|
0000c4  0030              MOVS     r0,r6                 ;31
0000c6  f1a60101          SUB      r1,r6,#1              ;31
0000ca  b2ce              UXTB     r6,r1                 ;31
0000cc  d1c6              BNE      |L1.92|
                  |L1.206|
0000ce  bf00              NOP      
;;;50                 }
;;;51             }                       
;;;52         }           
;;;53         if(retry==0)temp=1; //检测失败
0000d0  b906              CBNZ     r6,|L1.212|
0000d2  2501              MOVS     r5,#1
                  |L1.212|
;;;54         return temp;     
0000d4  4628              MOV      r0,r5
;;;55     }
0000d6  bdf8              POP      {r3-r7,pc}
;;;56     
                          ENDP

                  HC05_Get_Role PROC
;;;58     //返回值:0,从机;1,主机;0XFF,获取失败.                            
;;;59     u8 HC05_Get_Role(void){               
0000d8  b570              PUSH     {r4-r6,lr}
;;;60         u8 retry=0X0F;
0000da  260f              MOVS     r6,#0xf
;;;61         u8 temp,t;
;;;62         while(retry--)
0000dc  e032              B        |L1.324|
                  |L1.222|
;;;63         {
;;;64             GPIO_SetBits(GPIOC,EN_Pin); //KEY置高,进入AT模式
0000de  2120              MOVS     r1,#0x20
0000e0  483f              LDR      r0,|L1.480|
0000e2  f7fffffe          BL       GPIO_SetBits
;;;65             delay_ms(10);
0000e6  200a              MOVS     r0,#0xa
0000e8  f7fffffe          BL       delay_ms
;;;66             u2_printf("AT+ROLE?\r\n");  //查询角色
0000ec  a041              ADR      r0,|L1.500|
0000ee  f7fffffe          BL       u2_printf
;;;67             for(t=0;t<20;t++)           //最长等待200ms,来接收HC05模块的回应
0000f2  2500              MOVS     r5,#0
0000f4  e00a              B        |L1.268|
                  |L1.246|
;;;68             {
;;;69                 delay_ms(10);
0000f6  200a              MOVS     r0,#0xa
0000f8  f7fffffe          BL       delay_ms
;;;70                 if(USART1_RX_STA&0X8000)break;
0000fc  483b              LDR      r0,|L1.492|
0000fe  8800              LDRH     r0,[r0,#0]  ; USART1_RX_STA
000100  f4104f00          TST      r0,#0x8000
000104  d000              BEQ      |L1.264|
000106  e003              B        |L1.272|
                  |L1.264|
000108  1c68              ADDS     r0,r5,#1              ;67
00010a  b2c5              UXTB     r5,r0                 ;67
                  |L1.268|
00010c  2d14              CMP      r5,#0x14              ;67
00010e  dbf2              BLT      |L1.246|
                  |L1.272|
000110  bf00              NOP      
;;;71             }       
;;;72             GPIO_ResetBits(GPIOC,EN_Pin);                  //KEY拉低,退出AT模式
000112  2120              MOVS     r1,#0x20
000114  4832              LDR      r0,|L1.480|
000116  f7fffffe          BL       GPIO_ResetBits
;;;73             if(USART1_RX_STA&0X8000)    //接收到一次数据了
00011a  4834              LDR      r0,|L1.492|
00011c  8800              LDRH     r0,[r0,#0]  ; USART1_RX_STA
00011e  f4104f00          TST      r0,#0x8000
000122  d00f              BEQ      |L1.324|
;;;74             {
;;;75                 temp=USART1_RX_STA&0X7FFF;  //得到数据长度
000124  4831              LDR      r0,|L1.492|
000126  7804              LDRB     r4,[r0,#0]  ; USART1_RX_STA
;;;76                 USART1_RX_STA=0;             
000128  2000              MOVS     r0,#0
00012a  4930              LDR      r1,|L1.492|
00012c  8008              STRH     r0,[r1,#0]
;;;77                 if(temp==13&&USART1_RX_BUF[0]=='+')//接收到正确的应答了
00012e  2c0d              CMP      r4,#0xd
000130  d108              BNE      |L1.324|
000132  482f              LDR      r0,|L1.496|
000134  7800              LDRB     r0,[r0,#0]  ; USART1_RX_BUF
000136  282b              CMP      r0,#0x2b
000138  d104              BNE      |L1.324|
;;;78                 {
;;;79                     temp=USART1_RX_BUF[6]-'0';//得到主从模式值
00013a  482d              LDR      r0,|L1.496|
00013c  7980              LDRB     r0,[r0,#6]  ; USART1_RX_BUF
00013e  3830              SUBS     r0,r0,#0x30
000140  b2c4              UXTB     r4,r0
;;;80                     break;
000142  e004              B        |L1.334|
                  |L1.324|
000144  0030              MOVS     r0,r6                 ;62
000146  f1a60101          SUB      r1,r6,#1              ;62
00014a  b2ce              UXTB     r6,r1                 ;62
00014c  d1c7              BNE      |L1.222|
                  |L1.334|
00014e  bf00              NOP      
;;;81                 }
;;;82             }       
;;;83         }
;;;84         if(retry==0)temp=0XFF;//查询失败.
000150  b906              CBNZ     r6,|L1.340|
000152  24ff              MOVS     r4,#0xff
                  |L1.340|
;;;85         return temp;
000154  4620              MOV      r0,r4
;;;86     }           
000156  bd70              POP      {r4-r6,pc}
;;;87     //ATK-HC05设置命令
                          ENDP

                  HC05_Set_Cmd PROC
;;;90     //返回值:0,设置成功;其他,设置失败.                             
;;;91     u8 HC05_Set_Cmd(u8* atstr)
000158  e92d41f0          PUSH     {r4-r8,lr}
;;;92     {               
00015c  4605              MOV      r5,r0
;;;93         u8 retry=0X0F;
00015e  270f              MOVS     r7,#0xf
;;;94         u8 temp,t;
;;;95         while(retry--)
000160  e030              B        |L1.452|
                  |L1.354|
;;;96         {
;;;97             GPIO_SetBits(GPIOC,EN_Pin);                   //KEY置高,进入AT模式
000162  2120              MOVS     r1,#0x20
000164  481e              LDR      r0,|L1.480|
000166  f7fffffe          BL       GPIO_SetBits
;;;98             delay_ms(10);
00016a  200a              MOVS     r0,#0xa
00016c  f7fffffe          BL       delay_ms
;;;99             u2_printf("%s\r\n",atstr);  //发送AT字符串
000170  4629              MOV      r1,r5
000172  a023              ADR      r0,|L1.512|
000174  f7fffffe          BL       u2_printf
;;;100            GPIO_ResetBits(GPIOC,EN_Pin);                  //KEY拉低,退出AT模式
000178  2120              MOVS     r1,#0x20
00017a  4819              LDR      r0,|L1.480|
00017c  f7fffffe          BL       GPIO_ResetBits
;;;101            for(t=0;t<20;t++)           //最长等待100ms,来接收HC05模块的回应
000180  2600              MOVS     r6,#0
000182  e00a              B        |L1.410|
                  |L1.388|
;;;102            {
;;;103                if(USART1_RX_STA&0X8000)break;
000184  4819              LDR      r0,|L1.492|
000186  8800              LDRH     r0,[r0,#0]  ; USART1_RX_STA
000188  f4104f00          TST      r0,#0x8000
00018c  d000              BEQ      |L1.400|
00018e  e006              B        |L1.414|
                  |L1.400|
;;;104                delay_ms(5);
000190  2005              MOVS     r0,#5
000192  f7fffffe          BL       delay_ms
000196  1c70              ADDS     r0,r6,#1              ;101
000198  b2c6              UXTB     r6,r0                 ;101
                  |L1.410|
00019a  2e14              CMP      r6,#0x14              ;101
00019c  dbf2              BLT      |L1.388|
                  |L1.414|
00019e  bf00              NOP                            ;103
;;;105            }       
;;;106            if(USART1_RX_STA&0X8000)    //接收到一次数据了
0001a0  4812              LDR      r0,|L1.492|
0001a2  8800              LDRH     r0,[r0,#0]  ; USART1_RX_STA
0001a4  f4104f00          TST      r0,#0x8000
0001a8  d00c              BEQ      |L1.452|
;;;107            {
;;;108                temp=USART1_RX_STA&0X7FFF;  //得到数据长度
0001aa  4810              LDR      r0,|L1.492|
0001ac  7804              LDRB     r4,[r0,#0]  ; USART1_RX_STA
;;;109                USART1_RX_STA=0;             
0001ae  2000              MOVS     r0,#0
0001b0  490e              LDR      r1,|L1.492|
0001b2  8008              STRH     r0,[r1,#0]
;;;110                if(temp==4&&USART1_RX_BUF[0]=='O')//接收到正确的应答了
0001b4  2c04              CMP      r4,#4
0001b6  d105              BNE      |L1.452|
0001b8  480d              LDR      r0,|L1.496|
0001ba  7800              LDRB     r0,[r0,#0]  ; USART1_RX_BUF
0001bc  284f              CMP      r0,#0x4f
0001be  d101              BNE      |L1.452|
;;;111                {           
;;;112                    temp=0;
0001c0  2400              MOVS     r4,#0
;;;113                    break;           
0001c2  e004              B        |L1.462|
                  |L1.452|
0001c4  0038              MOVS     r0,r7                 ;95
0001c6  f1a70101          SUB      r1,r7,#1              ;95
0001ca  b2cf              UXTB     r7,r1                 ;95
0001cc  d1c9              BNE      |L1.354|
                  |L1.462|
0001ce  bf00              NOP      
;;;114                }
;;;115            }       
;;;116        }
;;;117        if(retry==0)
0001d0  b907              CBNZ     r7,|L1.468|
;;;118            temp=0XFF;//设置失败.
0001d2  24ff              MOVS     r4,#0xff
                  |L1.468|
;;;119        return temp;
0001d4  4620              MOV      r0,r4
;;;120    }
0001d6  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

0001da  0000              DCW      0x0000
                  |L1.476|
                          DCD      0x40010800
                  |L1.480|
                          DCD      0x40011000
                  |L1.484|
0001e4  41540d0a          DCB      "AT\r\n",0
0001e8  00      
0001e9  00                DCB      0
0001ea  00                DCB      0
0001eb  00                DCB      0
                  |L1.492|
                          DCD      USART1_RX_STA
                  |L1.496|
                          DCD      USART1_RX_BUF
                  |L1.500|
0001f4  41542b52          DCB      "AT+ROLE?\r\n",0
0001f8  4f4c453f
0001fc  0d0a00  
0001ff  00                DCB      0
                  |L1.512|
000200  25730d0a          DCB      "%s\r\n",0
000204  00      
000205  00                DCB      0
000206  00                DCB      0
000207  00                DCB      0
